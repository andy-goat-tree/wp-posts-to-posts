<html>
    <head>
        <script type="text/javascript" src="../../js/jquery-1.4.2.min.js"></script>
        <script type="text/javascript" src="../../syntax_highlighter/scripts/shCore.js"></script>
        <script type="text/javascript" src="../../syntax_highlighter/scripts/shBrushJScript.js"></script>
        <script type="text/javascript" src="../../syntax_highlighter/scripts/shBrushPhp.js"></script>
        <script type="text/javascript" src="../../syntax_highlighter/scripts/shBrushXml.js"></script>
        <link href="../../syntax_highlighter/styles/shCore.css" rel="stylesheet" type="text/css" />
        <link href="../../syntax_highlighter/styles/shCoreEclipse.css" rel="stylesheet" type="text/css" />
        <link href="../../syntax_highlighter/styles/shThemeWordpress.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <pre class="brush: php">&lt;?php

class P2P_Connection_Type {

	private static $instances = array();

	public function register( $args ) {
		$args = wp_parse_args( $args, array(
			'id' =&gt; false,
			'from' =&gt; '',
			'to' =&gt; '',
			'from_query_vars' =&gt; array(),
			'to_query_vars' =&gt; array(),
			'data' =&gt; array(),
			'indeterminate_direction' =&gt; 'any',
			'cardinality' =&gt; 'many-to-many',
			'prevent_duplicates' =&gt; true,
			'sortable' =&gt; false,
			'title' =&gt; '',
		) );

		foreach ( array( 'from', 'to' ) as $key ) {
			if ( isset( $args[ $key ] ) ) {
				$args[&quot;{$key}_query_vars&quot;]['post_type'] = (array) $args[ $key ];
				unset( $args[ $key ] );
			}

			if ( empty( $args[&quot;{$key}_query_vars&quot;]['post_type'] ) )
				$args[&quot;{$key}_query_vars&quot;]['post_type'] = array( 'post' );
		}

		$id =&amp; $args['id'];

		if ( !$id ) {
			$id = md5( serialize( wp_array_slice_assoc( $args, array( 'from_query_vars', 'to_query_vars', 'data' ) ) ) );
		}

		if ( isset( self::$instances[ $id ] ) ) {
			trigger_error( 'Connection type is already defined.', E_USER_NOTICE );
		}

		return self::$instances[ $id ] = new P2P_Connection_Type( $args );
	}

	public function get( $hash = false ) {
		if ( !$hash )
			return self::$instances;

		if ( isset( self::$instances[ $hash ] ) )
			return self::$instances[ $hash ];

		return false;
	}


	protected $args;
	protected $indeterminate;

	protected function __construct( $args ) {
		$this-&gt;args = $args;

		$common = array_intersect( $this-&gt;from, $this-&gt;to );

		if ( !empty( $common ) )
			$this-&gt;indeterminate = true;
	}

	public function __get( $key ) {
		if ( in_array( $key, array( 'from', 'to' ) ) )
			return $this-&gt;args[ &quot;{$key}_query_vars&quot; ]['post_type'];

		return $this-&gt;args[$key];
	}

	protected function make_directed( $direction ) {
		if ( !$direction )
			return false;

		if ( $this-&gt;indeterminate ) {
			return new P2P_Indeterminate_Connection_Type( $this, $this-&gt;indeterminate_direction );
		}

		return new P2P_Directed_Connection_Type( $this, $direction );
	}

	/**
	 * Get connection direction.
	 *
	 * @param int|string $arg A post id or a post type.
	 *
	 * @return bool|string False on failure, 'any', 'to' or 'from' on success.
	 */
	public function find_direction( $arg ) {
		if ( $post_id = (int) $arg ) {
			$post = get_post( $post_id );
			if ( !$post )
				return false;
			$post_type = $post-&gt;post_type;
		} else {
			$post_type = $arg;
		}

		return $this-&gt;make_directed( $this-&gt;_find_direction( $post_type ) );
	}

	protected function _find_direction( $post_type ) {
		if ( in_array( $post_type, $this-&gt;from ) ) {
			$direction = 'from';
		} elseif ( in_array( $post_type, $this-&gt;to ) ) {
			$direction = 'to';
		} else {
			$direction = false;
		}

		return $direction;
	}

	/**
	 * Get a list of posts that are connected to a given post.
	 *
	 * @param int $post_id A post id.
	 * @param array $extra_qv Additional query variables to use.
	 *
	 * @return bool|object False on failure; A WP_Query instance on success.
	 */
	public function get_connected( $post_id, $extra_qv = array() ) {
		$directed = $this-&gt;find_direction( $post_id );
		if ( !$directed )
			return false;

		return $directed-&gt;get_connected( $post_id, $extra_qv );
	}

	public function get_connected_to( $post_id, $extra_qv = array() ) {
		$directed = $this-&gt;make_directed( 'from' );

		$directed-&gt;get_connected( $post_id, $extra_qv );
	}

	/**
	 * Get a list of posts that could be connected to a given post.
	 *
	 * @param int $post_id A post id.
	 * @param array $extra_qv Additional query variables to use.
	 *
	 * @return bool|object False on failure; A WP_Query instance on success.
	 */
	public function get_connectable( $post_id, $extra_qv = array() ) {
		$directed = $this-&gt;find_direction( $post_id );
		if ( !$directed )
			return false;

		return $directed-&gt;get_connectable( $post_id, $extra_qv );
	}

	/**
	 * Optimized inner query, after the outer query was executed.
	 *
	 * Populates each of the outer querie's $post objects with a 'connected' property, containing a list of connected posts
	 *
	 * @param object $query WP_Query instance.
	 * @param string|array $extra_qv Additional query vars for the inner query.
	 */
	public function each_connected( $query, $extra_qv = array() ) {
		if ( empty( $query-&gt;posts ) || !is_object( $query-&gt;posts[0] ) )
			return;

		$post_type = $query-&gt;get( 'post_type' );
		if ( empty( $post_type ) )
			$post_type = 'post';

		$directed = $this-&gt;find_direction( $post_type );
		if ( !$directed )
			return false;

		$prop_name = 'connected';

		$posts = array();

		foreach ( $query-&gt;posts as $post ) {
			$post-&gt;$prop_name = array();
			$posts[ $post-&gt;ID ] = $post;
		}

		// ignore pagination
		foreach ( array( 'showposts', 'posts_per_page', 'posts_per_archive_page' ) as $disabled_qv ) {
			if ( isset( $extra_qv[ $disabled_qv ] ) ) {
				trigger_error( &quot;Can't use '$disabled_qv' in an inner query&quot;, E_USER_WARNING );
			}
		}
		$extra_qv['nopaging'] = true;

		$q = $directed-&gt;get_connected( array_keys( $posts ), $extra_qv );

		foreach ( $q-&gt;posts as $inner_post ) {
			if ( $inner_post-&gt;ID == $inner_post-&gt;p2p_from )
				$outer_post_id = $inner_post-&gt;p2p_to;
			elseif ( $inner_post-&gt;ID == $inner_post-&gt;p2p_to )
				$outer_post_id = $inner_post-&gt;p2p_from;
			else {
				trigger_error( &quot;Corrupted data for post $inner_post-&gt;ID&quot;, E_USER_WARNING );
				continue;
			}

			if ( $outer_post_id == $inner_post-&gt;ID ) {
				trigger_error( 'Post connected to itself.', E_USER_WARNING );
				continue;
			}

			array_push( $posts[ $outer_post_id ]-&gt;$prop_name, $inner_post );
		}
	}

	/**
	 * Connect two posts.
	 *
	 * @param int The first end of the connection.
	 * @param int The second end of the connection.
	 *
	 * @return int p2p_id
	 */
	public function connect( $from, $to ) {
		$directed = $this-&gt;find_direction( $from );
		if ( !$directed )
			return false;

		return $directed-&gt;connect( $from, $to );
	}

	/**
	 * Disconnect two posts.
	 *
	 * @param int The first end of the connection.
	 * @param int The second end of the connection.
	 */
	public function disconnect( $from, $to ) {
		$directed = $this-&gt;find_direction( $from );
		if ( !$directed )
			return false;

		return $directed-&gt;disconnect( $from, $to );
	}

	/**
	 * Delete all connections for a certain post.
	 *
	 * @param int The post id.
	 */
	public function disconnect_all( $from ) {
		$directed = $this-&gt;find_direction( $from );
		if ( !$directed )
			return false;

		return $directed-&gt;disconnect_all( $from );
	}

	/**
	 * Delete a connection.
	 *
	 * @param int p2p_id
	 */
	public function delete_connection( $p2p_id ) {
		return P2P_Storage::delete( $p2p_id );
	}

	public function get_p2p_id( $from, $to ) {
		$directed = $this-&gt;find_direction( $from );
		if ( !$directed )
			return false;

		return $directed-&gt;get_p2p_id( $from, $to );
	}
}

</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all()
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>